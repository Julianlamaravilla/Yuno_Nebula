"""
Yuno Sentinel - Pydantic Schemas
Strict data contracts matching Yuno Official Payment Object
"""
from datetime import datetime
from typing import Optional, Literal
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from decimal import Decimal


# ============================================
# INPUT: Payment Transaction Schemas
# ============================================

class AmountSchema(BaseModel):
    """Payment amount with currency"""
    value: Decimal = Field(..., gt=0, description="Transaction amount")
    currency: str = Field(..., min_length=3, max_length=3, description="ISO 4217 currency code")


class CardDetail(BaseModel):
    """Card payment details"""
    brand: str = Field(..., description="Card brand (VISA, MASTERCARD, AMEX)")
    issuer_name: str = Field(..., description="Issuing bank name (CRITICAL for analysis)")
    bin: str = Field(..., min_length=6, max_length=6, description="Bank Identification Number")


class CardWrapper(BaseModel):
    """Wrapper for card detail"""
    card: CardDetail


class PaymentMethod(BaseModel):
    """Payment method information"""
    type: Literal["CARD", "WALLET", "BANK_TRANSFER"] = Field(..., description="Payment method type")
    detail: CardWrapper


class ProviderData(BaseModel):
    """Payment provider response data"""
    id: str = Field(..., description="Provider ID (STRIPE, DLOCAL, ADYEN)")
    merchant_advice_code: Optional[str] = Field(None, description="Provider advice for retry logic")
    response_code: str = Field(..., description="Provider response code")


class PaymentEvent(BaseModel):
    """
    Complete Payment Transaction Event
    Matches Yuno Official Docs - "The Payment Object"
    """
    id: str = Field(..., description="Transaction UUID v4")
    created_at: datetime = Field(..., description="ISO8601 timestamp")
    merchant_id: str = Field(..., description="Merchant identifier")
    country: str = Field(..., min_length=2, max_length=2, description="ISO 3166-1 alpha-2 country code")
    status: Literal["CREATED", "SUCCEEDED", "DECLINED", "ERROR", "REJECTED"] = Field(
        ...,
        description="Transaction status"
    )
    sub_status: Optional[Literal["TIMEOUT", "INSUFFICIENT_FUNDS", "FRAUD", "DO_NOT_HONOR"]] = Field(
        None,
        description="Detailed failure reason"
    )
    amount: AmountSchema
    payment_method: PaymentMethod
    provider_data: ProviderData
    latency_ms: int = Field(..., ge=0, description="Provider response latency in milliseconds")

    @field_validator('id')
    @classmethod
    def validate_uuid(cls, v: str) -> str:
        """Validate UUID format"""
        try:
            UUID(v)
            return v
        except ValueError:
            raise ValueError(f"Invalid UUID format: {v}")


# ============================================
# OUTPUT: Alert Schemas
# ============================================

class RootCauseSchema(BaseModel):
    """Root cause analysis of the incident"""
    provider: str = Field(..., description="Affected provider")
    issue: str = Field(..., description="Issue description")
    scope: str = Field(..., description="Scope of impact (e.g., 'BBVA Issuers only')")


class SuggestedActionSchema(BaseModel):
    """Actionable recommendation"""
    label: str = Field(..., description="Action label (e.g., 'Reroute to dLocal')")
    action_type: Literal["FAILOVER_PROVIDER", "PAUSE_TRAFFIC", "INCREASE_TIMEOUT", "CONTACT_ISSUER"] = Field(
        ...,
        description="Type of recommended action"
    )


class ImpactSchema(BaseModel):
    """Financial and operational impact"""
    revenue_at_risk_usd: Decimal = Field(..., ge=0, description="Revenue at risk in USD")
    affected_transactions: int = Field(..., ge=0, description="Number of affected transactions")
    sla_breach_countdown_seconds: Optional[int] = Field(None, description="Time until SLA breach")


class AlertSchema(BaseModel):
    """
    Alert Output Schema
    Generated by Worker when anomaly is detected
    """
    alert_id: str = Field(..., description="Alert UUID")
    timestamp: datetime = Field(..., description="Alert creation time")
    severity: Literal["CRITICAL", "WARNING"] = Field(..., description="Alert severity")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="Detection confidence (0.0-1.0)")
    title: str = Field(..., max_length=255, description="Alert title")
    description_llm: Optional[str] = Field(None, description="LLM-generated explanation")
    impact: ImpactSchema
    root_cause: RootCauseSchema
    suggested_action: SuggestedActionSchema


# ============================================
# DATABASE: ORM Models (SQLAlchemy)
# ============================================

class EventLogCreate(BaseModel):
    """Schema for creating event_log records"""
    merchant_id: str
    provider_id: str
    status: str
    amount_usd: Decimal
    raw_payload: dict

    class Config:
        from_attributes = True


class AlertCreate(BaseModel):
    """Schema for creating alert records"""
    severity: str
    confidence_score: float
    title: str
    revenue_at_risk_usd: Decimal
    affected_transactions: int
    sla_breach_countdown_seconds: Optional[int]
    root_cause: dict
    llm_explanation: Optional[str]
    suggested_action: dict

    class Config:
        from_attributes = True


# ============================================
# ALERT RULES: CRUD Schemas
# ============================================

class AlertRuleCreate(BaseModel):
    """Schema for creating alert rules"""
    merchant_id: Optional[str] = Field(None, description="Merchant ID (NULL = global rule)")
    rule_name: str = Field(..., max_length=255, description="Human-readable rule name")

    # Filters (NULL = applies to all)
    filter_country: Optional[str] = Field(None, min_length=2, max_length=2, description="ISO country code filter")
    filter_provider: Optional[str] = Field(None, max_length=50, description="Provider filter (STRIPE, DLOCAL, etc.)")
    filter_issuer: Optional[str] = Field(None, max_length=100, description="Issuer filter (BBVA, Santander, etc.)")

    # Metric configuration
    metric_type: Literal["APPROVAL_RATE", "ERROR_RATE", "DECLINE_RATE", "TOTAL_VOLUME"] = Field(
        ...,
        description="Type of metric to monitor"
    )
    operator: Literal["<", ">", "<=", ">="] = Field(..., description="Comparison operator")
    threshold_value: Decimal = Field(..., ge=0, description="Threshold value for triggering alert")
    min_transactions: int = Field(10, ge=1, description="Minimum sample size before evaluation")

    # Time-based rules
    is_time_based: bool = Field(False, description="Whether rule is time-constrained")
    start_hour: Optional[int] = Field(None, ge=0, lt=24, description="Start hour (0-23) for time-based rules")
    end_hour: Optional[int] = Field(None, ge=0, lt=24, description="End hour (0-23) for time-based rules")

    # Alert action
    severity: Literal["CRITICAL", "WARNING"] = Field("WARNING", description="Alert severity level")

    @field_validator('start_hour', 'end_hour')
    @classmethod
    def validate_time_hours(cls, v, info):
        """Validate that time hours are provided if is_time_based is True"""
        if info.data.get('is_time_based') and v is None:
            raise ValueError(f"{info.field_name} is required when is_time_based is True")
        return v

    class Config:
        from_attributes = True


class AlertRuleResponse(BaseModel):
    """Schema for alert rule responses"""
    rule_id: UUID = Field(..., description="Unique rule identifier")
    merchant_id: Optional[str]
    rule_name: str

    # Filters
    filter_country: Optional[str]
    filter_provider: Optional[str]
    filter_issuer: Optional[str]

    # Metric configuration
    metric_type: str
    operator: str
    threshold_value: Decimal
    min_transactions: int

    # Time-based rules
    is_time_based: bool
    start_hour: Optional[int]
    end_hour: Optional[int]

    # Alert action
    severity: str
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True


# Type aliases for frontend convenience
RuleCreate = AlertRuleCreate
RuleResponse = AlertRuleResponse


# ============================================
# UTILITY: Currency Conversion
# ============================================

CURRENCY_TO_USD_RATES = {
    "USD": 1.0,
    "MXN": 0.059,  # Approximate rate
    "COP": 0.00025,
    "BRL": 0.20,
    "EUR": 1.10,
    "GBP": 1.27,
}


def convert_to_usd(amount: Decimal, currency: str) -> Decimal:
    """Convert amount to USD using static rates"""
    rate = Decimal(str(CURRENCY_TO_USD_RATES.get(currency, 1.0)))
    return (amount * rate).quantize(Decimal("0.01"))
